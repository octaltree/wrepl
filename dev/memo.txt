純粋なpythonファイルを入力とする。
ファイルスコープの文ごとに実行する。
文は副作用を持たないことを期待して差分だけを実行する。
そのためにグローバル変数を保存する。
開発においては式を確認して変数に保存することが多いため、
代入文, 式文でprintできるようにする。
長い時間をかけ式を評価したあと変数に保存するのにまた時間がかかるのは虚しいため、
式文はキャッシュする。
astモジュールで1文ずつにして
symtableモジュールでグローバル変数への依存を解析する。


## 読み込み
* referencedなシンボルうちモジュールレベルのものを読み込む
* importedか否かで読み込み方法が変わる

## 保存対象
* (referenced あるいは assigned)なシンボルのうちモジュールレベルのものを変数として保存する
* importedなシンボルのうちモジュールレベルのものをimport文として保存する

## モジュールレベル とは
type moduleなテーブルのシンボルでlocalがtrue
あるいは
その他テーブルの(declared_globalがtrue あるいは globalがtrue)

1文ずつsymtableすると結果が変わるのでこのルールは使えない
だがcell.py実装終えた

## 実行計画
addedについて1文ずつ実行する
この際

メモリに読み込んであるものを一々保存読み込みするのは無駄

* 保存されたScript
* インタプリタで実行された[Cell]
* 最新のScript
保存されたと最新のを比較して(same :: [Cell], deleted, added)が得られる。
sameのうち必要なCellをメモリに読み込みaddedを実行
その際deletedで上書きされた変数があればインタプリタをrefresh
最新のscriptを保存されたScriptとする

* 保存された[Cell]
* 実行済みでリフレッシュするしかない[Cell]
* 最新の[Cell]
3通りの(same :: [Cell], deleted, added)が得られる
どういう場合にリフレッシュするか




cell.neededが必要
それがlazyな文でchangedされたものだったらさらにその文のwillNeededが必要
必要なのを探して見つかったcellについても再帰

importedを保存 changedを保存
changedのいずれかがlazyな文でchangedされたものだったらさらにその文のwillImported, willChangedを保存
changedについて再帰
